<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/bootstrap.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/katex.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <link rel="stylesheet" href="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/cs161.css">
    <title>Assembly 2: Calling convention – CS 61</title>
  <script async="" src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/async-ads.js"></script><script src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/cse_element__en.js" type="text/javascript"></script><link type="text/css" rel="stylesheet" href="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/defaulten.css"><link type="text/css" rel="stylesheet" href="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/default.css"><style type="text/css">.gsc-control-cse{font-family:arial, sans-serif}.gsc-control-cse .gsc-table-result{font-family:arial, sans-serif}.gsc-refinementsGradient{background:linear-gradient(to left,rgba(255,255,255,1),rgba(255,255,255,0))}.gsc-control-cse{border-color:#FFFFFF;background-color:#FFFFFF}input.gsc-input,.gsc-input-box,.gsc-input-box-hover,.gsc-input-box-focus{border-color:#D9D9D9}.gsc-search-button-v2,.gsc-search-button-v2:hover,.gsc-search-button-v2:focus{border-color:#666666;background-color:#CECECE;background-image:none;filter:none}.gsc-search-button-v2 svg{fill:#FFFFFF}.gsc-tabHeader.gsc-tabhActive,.gsc-refinementHeader.gsc-refinementhActive{color:#CCCCCC;border-color:#CCCCCC;background-color:#FFFFFF}.gsc-tabHeader.gsc-tabhInactive,.gsc-refinementHeader.gsc-refinementhInactive{color:#CCCCCC;border-color:#CCCCCC;background-color:#FFFFFF}.gsc-webResult.gsc-result,.gsc-results .gsc-imageResult{border-color:#FFFFFF;background-color:#FFFFFF}.gsc-webResult.gsc-result:hover,.gsc-imageResult:hover{border-color:#FFFFFF;background-color:#FFFFFF}.gs-webResult.gs-result a.gs-title:link,.gs-webResult.gs-result a.gs-title:link b,.gs-imageResult a.gs-title:link,.gs-imageResult a.gs-title:link b{color:#0000CC}.gs-webResult.gs-result a.gs-title:visited,.gs-webResult.gs-result a.gs-title:visited b,.gs-imageResult a.gs-title:visited,.gs-imageResult a.gs-title:visited b{color:#0000CC}.gs-webResult.gs-result a.gs-title:hover,.gs-webResult.gs-result a.gs-title:hover b,.gs-imageResult a.gs-title:hover,.gs-imageResult a.gs-title:hover b{color:#0000CC}.gs-webResult.gs-result a.gs-title:active,.gs-webResult.gs-result a.gs-title:active b,.gs-imageResult a.gs-title:active,.gs-imageResult a.gs-title:active b{color:#0000CC}.gsc-cursor-page{color:#0000CC}a.gsc-trailing-more-results:link{color:#0000CC}.gs-webResult .gs-snippet,.gs-imageResult .gs-snippet,.gs-fileFormatType{color:#000000}.gs-webResult div.gs-visibleUrl,.gs-imageResult div.gs-visibleUrl{color:#008000}.gs-webResult div.gs-visibleUrl-short{color:#008000}.gs-webResult div.gs-visibleUrl-short{display:none}.gs-webResult div.gs-visibleUrl-long{display:block}.gs-promotion div.gs-visibleUrl-short{display:none}.gs-promotion div.gs-visibleUrl-long{display:block}.gsc-cursor-box{border-color:#FFFFFF}.gsc-results .gsc-cursor-box .gsc-cursor-page{border-color:#CCCCCC;background-color:#FFFFFF;color:#CCCCCC}.gsc-results .gsc-cursor-box .gsc-cursor-current-page{border-color:#CCCCCC;background-color:#FFFFFF;color:#CCCCCC}.gsc-webResult.gsc-result.gsc-promotion{border-color:#336699;background-color:#FFFFFF}.gsc-completion-title{color:#0000CC}.gsc-completion-snippet{color:#000000}.gs-promotion a.gs-title:link,.gs-promotion a.gs-title:link *,.gs-promotion .gs-snippet a:link{color:#0000CC}.gs-promotion a.gs-title:visited,.gs-promotion a.gs-title:visited *,.gs-promotion .gs-snippet a:visited{color:#0000CC}.gs-promotion a.gs-title:hover,.gs-promotion a.gs-title:hover *,.gs-promotion .gs-snippet a:hover{color:#0000CC}.gs-promotion a.gs-title:active,.gs-promotion a.gs-title:active *,.gs-promotion .gs-snippet a:active{color:#0000CC}.gs-promotion .gs-snippet,.gs-promotion .gs-title .gs-promotion-title-right,.gs-promotion .gs-title .gs-promotion-title-right *{color:#000000}.gs-promotion .gs-visibleUrl,.gs-promotion .gs-visibleUrl-short{color:#008000}.gcsc-find-more-on-google{color:#0000CC}.gcsc-find-more-on-google-magnifier{fill:#0000CC}</style><style type="text/css">.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}.gsst_a:hover .gscb_a,.gsst_a:focus .gscb_a{color:#36c}.gsst_a{display:inline-block}.gsst_a{cursor:pointer;padding:0 4px}.gsst_a:hover{text-decoration:none!important}.gsst_b{font-size:16px;padding:0 2px;position:relative;user-select:none;-moz-user-select:none;white-space:nowrap}.gsst_e{vertical-align:middle;opacity:0.55;}.gsst_a:hover .gsst_e,.gsst_a:focus .gsst_e{opacity:0.72;}.gsst_a:active .gsst_e{opacity:1;}.gsst_f{background:white;text-align:left}.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-moz-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}.gssb_c{border:0;position:absolute;z-index:989}.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-moz-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}.gssb_f{visibility:hidden;white-space:nowrap}.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsq_a{padding:0}.gssb_a{padding:0 7px}.gssb_a,.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}.gssb_g{text-align:center;padding:8px 0 7px;position:relative}.gssb_h{font-size:15px;height:28px;margin:0.2em}.gssb_i{background:#eee}.gss_ifl{visibility:hidden;padding-left:5px}.gssb_i .gss_ifl{visibility:visible}a.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a.gssb_j:hover{text-decoration:underline}.gssb_l{height:1px;background-color:#e5e5e5}.gssb_m{color:#000;background:#fff}.gssb_a{padding:0 9px}.gsib_a{padding:5px 9px 4px 9px}.gscb_a{line-height:27px}.gssb_e{border:0}.gssb_l{margin:5px 0}input.gsc-input::-webkit-input-placeholder{font-size:14px}input.gsc-input:-moz-placeholder{font-size:14px}input.gsc-input::-moz-placeholder{font-size:14px}input.gsc-input:-ms-input-placeholder{font-size:14px}input.gsc-input:focus::-webkit-input-placeholder{color:transparent}input.gsc-input:focus:-moz-placeholder{color:transparent}input.gsc-input:focus::-moz-placeholder{color:transparent}input.gsc-input:focus:-ms-input-placeholder{color:transparent}.gssb_c .gsc-completion-container{position:static}.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}.gssb_c > tbody > tr,.gssb_c > tbody > tr > td,.gssb_d,.gssb_d > tbody > tr,.gssb_d > tbody > tr > td,.gssb_e,.gssb_e > tbody > tr,.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}.gssb_a table,.gssb_a table tr,.gssb_a table tr td{padding:0;margin:0;border:0}</style></head>
  <body>

<nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand" href="https://cs61.seas.harvard.edu/site/2018/">CS 61 2018</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="nav-dropdown-info" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Info
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-info">
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Concepts/">Concepts</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/CourseDescription/">Course Description</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Staff/">Course Staff</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Extension/">Extension</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/ZoomOH/">Extension School Zoom Office Hours</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Prerequisites/">Prerequisites</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Resources/">Resources</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Schedule/">Schedule</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Style/">Style</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Textbook/">Textbook</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Infrastructure/">Infrastructure</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/DatarepEx/">Exercises: Data representation</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/AsmEx/">Exercises: Assembly</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/KernelEx/">Exercises: Kernel</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/StorageEx/">Exercises: Storage</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/ShellEx/">Exercises: Process control</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/SynchEx/">Exercises: Synchronization</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/MiscEx/">Exercises: Miscellaneous</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Patterns/">C and C++ Patterns</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/diff/">Diff</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/file-descriptors/">File Descriptors</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/gdb-commands/">GDB Commands</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/gdb/">GDB Introduction</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/git/">Git</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/ref/http/">HTTP</a>
    
    </div>
  </li>
      <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="nav-dropdown-psets" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Problem sets
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-psets">
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Dmalloc/">Problem set 1</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/BinaryBomb/">Problem set 2</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Stdio/">Problem set 3</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/WeensyOS/">Problem set 4</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Shell/">Problem set 5</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Pong/">Problem set 6</a>
    
    </div>
  </li>
      <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="nav-dropdown-lectures" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Lectures
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-lectures">
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Datarep2/">Data representation 2: Object representation</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Datarep3/">Data representation 3: Layout</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Datarep4/">Data representation 4: Pointers and undefined behavior</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Datarep5/">Data representation 5: Undefined behavior, bitwise operations, arena allocation</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Datarep6/">Data representation 6: Arena allocation</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Assembly 1: Basics</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Asm2/">Assembly 2: Calling convention</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Asm3/">Assembly 3: Optimizations and assembly</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Asm4/">Assembly 4: Buffer overflows</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Storage1/">Storage 1: Caches</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Storage2/">Storage 2: Cache model</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Storage3/">Storage 3: Stdio cache</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Storage4/">Storage 4: Consistency</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Kernel1/">Kernel 1: Robustness and safety</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Kernel2/">Kernel 2: Process isolation and virtual memory</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Kernel3/">Kernel 3: x86-64 page tables and WeensyOS</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Kernel4/">Kernel 4: Protection and isolation</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Kernel5/">Kernel 5: Confused deputy attack, scheduling, and process management</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Shell1/">Shell 1: Process control</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Shell2/">Shell 2: Process creation and interprocess communication</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Shell3/">Shell 3: Sieve of Eratosthenes, polling vs. blocking</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Synch1/">Synchronization 1: Signals, race condition, threads</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Synch2/">Synchronization 2: Mutex, bounded buffers</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Synch3/">Synchronization 3: Mutexes, condition variables, and compare-exchange</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Synch4/">Synchronization 4: Networking and Synchronization</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Synch5/">Synchronization 5: Deadlock and Server Programming</a>
    
    </div>
  </li>
      <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" href="#" id="nav-dropdown-sections" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Sections
    </a>
    <div class="dropdown-menu" aria-labelledby="nav-dropdown-sections">
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section1/">Section 1</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section2/">Section 2</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section3/">Section 3</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section4/">Section 4</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section5/">Section 5</a>
    
      <a class="dropdown-item" href="https://cs61.seas.harvard.edu/site/2018/Section6/">Section 6</a>
    
    </div>
  </li>
      
  <li class="nav-item">
    
      <a class="nav-link" href="https://cs61.seas.harvard.edu/site/2018/Schedule/">Schedule</a>
    
  </li>
      <li class="nav-item"><script type="text/javascript" async="" src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/cse.js"></script><script>
  (function() {
    var cx ='001870065194094800801:cru2ukzhywq';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script><div id="___gcse_0"><div class="gsc-control-cse gsc-control-cse-en"><div class="gsc-control-wrapper-cse" dir="ltr"><form class="gsc-search-box gsc-search-box-tools" accept-charset="utf-8"><table class="gsc-search-box" cellspacing="0" cellpadding="0"><tbody><tr><td class="gsc-input"><div class="gsc-input-box" id="gsc-iw-id1"><table style="width: 100%; padding: 0px;" id="gs_id50" class="gstl_50 gsc-input" cellspacing="0" cellpadding="0"><tbody><tr><td id="gs_tti50" class="gsib_a"><input autocomplete="off" type="text" size="10" class="gsc-input" name="search" title="search" style="width: 100%; padding: 0px; border: medium none; margin: 0px; height: auto; outline: currentcolor none medium;" id="gsc-i-id1" dir="ltr" spellcheck="false"></td><td class="gsib_b"><div class="gsst_b" id="gs_st50" dir="ltr"><a class="gsst_a" href="javascript:void(0)" style="display: none;" title="Clear search box" role="button"><span class="gscb_a" id="gs_cb50" aria-hidden="true">×</span></a></div></td></tr></tbody></table></div></td><td class="gsc-search-button"><button class="gsc-search-button gsc-search-button-v2"><svg width="13" height="13" viewBox="0 0 13 13"><title>search</title><path d="m4.8495 7.8226c0.82666 0 1.5262-0.29146 2.0985-0.87438 0.57232-0.58292 0.86378-1.2877 0.87438-2.1144 0.010599-0.82666-0.28086-1.5262-0.87438-2.0985-0.59352-0.57232-1.293-0.86378-2.0985-0.87438-0.8055-0.010599-1.5103 0.28086-2.1144 0.87438-0.60414 0.59352-0.8956 1.293-0.87438 2.0985 0.021197 0.8055 0.31266 1.5103 0.87438 2.1144 0.56172 0.60414 1.2665 0.8956 2.1144 0.87438zm4.4695 0.2115 3.681 3.6819-1.259 1.284-3.6817-3.7 0.0019784-0.69479-0.090043-0.098846c-0.87973 0.76087-1.92 1.1413-3.1207 1.1413-1.3553 0-2.5025-0.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239c0-1.3553 0.4696-2.4966 1.4088-3.4239 0.9392-0.92727 2.0864-1.3969 3.4417-1.4088 1.3553-0.011889 2.4906 0.45771 3.406 1.4088 0.9154 0.95107 1.379 2.0924 1.3909 3.4239 0 1.2126-0.38043 2.2588-1.1413 3.1385l0.098834 0.090049z"></path></svg></button></td><td class="gsc-clear-button"><div class="gsc-clear-button" title="clear results">&nbsp;</div></td></tr></tbody></table></form><div class="gsc-results-wrapper-overlay"><div class="gsc-results-close-btn" tabindex="0"></div><div class="gsc-positioningWrapper"><div class="gsc-tabsAreaInvisible"><div aria-label="refinement" role="tab" class="gsc-tabHeader gsc-inline-block gsc-tabhActive">Custom Search</div><span class="gs-spacer"> </span></div></div><div class="gsc-positioningWrapper"><div class="gsc-tabsAreaInvisible"></div></div><div class="gsc-above-wrapper-area-invisible"><table class="gsc-above-wrapper-area-container" cellspacing="0" cellpadding="0"><tbody><tr><td class="gsc-result-info-container"><div class="gsc-result-info-invisible"></div></td><td class="gsc-orderby-container"><div class="gsc-orderby-invisible"><div class="gsc-orderby-label gsc-inline-block">Sort by:</div><div class="gsc-option-menu-container gsc-inline-block"><div class="gsc-selected-option-container gsc-inline-block"><div class="gsc-selected-option">Relevance</div><div class="gsc-option-selector"></div></div><div class="gsc-option-menu-invisible"><div class="gsc-option-menu-item gsc-option-menu-item-highlighted"><div class="gsc-option">Relevance</div></div><div class="gsc-option-menu-item"><div class="gsc-option">Date</div></div></div></div></div></td></tr></tbody></table></div><div class="gsc-adBlockInvisible"></div><div class="gsc-wrapper"><div class="gsc-adBlockInvisible"></div><div class="gsc-resultsbox-invisible"><div class="gsc-resultsRoot gsc-tabData gsc-tabdActive"><div><div class="gsc-expansionArea"></div></div></div></div></div></div><div class="gsc-modal-background-image" tabindex="0"></div></div></div></div></li>
    </ul>
  </div>
</nav>


<img src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/cs61hello.jpg" class="hellobackground">


<div class="container">
    <h1><a href="https://cs61.seas.harvard.edu/site/2018/Asm2/">Assembly 2: Calling convention</a></h1>
    <div class="post">
        <h2 id="calling-convention">Calling convention</h2>

<p>A <a href="https://en.wikipedia.org/wiki/Calling_convention"><strong>calling convention</strong></a>
governs how functions on a particular architecture and operating system
interact. This includes rules about includes how function arguments are
placed, where return values go, what registers functions may use, how they may
allocate local variables, and so forth. Calling conventions ensure that
functions compiled by different compilers can interoperate, and they ensure
that operating systems can run code from different programming languages and
compilers. Some aspects of a calling convention are derived from the
instruction set itself, but some are conventional, meaning decided upon by
people (for instance, at a convention).</p>

<p>Calling conventions constrain both <em>callers</em> and <em>callees</em>. A caller is a
function that calls another function; a callee is a function that was called.
The currently-executing function is a callee, but not a caller.</p>

<p>For concreteness, we learn the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">x86-64 calling conventions for
Linux</a>.
These conventions are shared by many OSes, including MacOS (but not Windows),
and are officially called the “System V AMD64 ABI.”</p>

<p>The official specification: <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">AMD64 ABI</a></p>

<h2 id="argument-passing-and-stack-frames">Argument passing and stack frames</h2>

<p>One set of calling convention rules governs how function arguments and return
values are passed. On x86-64 Linux, the first six function arguments are
passed in registers <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code>,
respectively. The seventh and subsequent arguments are passed on the stack,
about which more below. The return value is passed in register <code>%rax</code>.</p>

<p>The full rules more complex than this. You can read them in <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">the AMD64
ABI</a>, section 3.2.3, but they’re quite detailed. Some highlights:</p>

<ol>
<li><p>A structure argument that fits in a single machine word (64 bits/8 bytes)
is passed in a single register.</p>

<p>Example: <code>struct small { char a1, a2; }</code></p></li>

<li><p>A structure that fits in two to four machine words (16–32 bytes) is passed
in sequential registers, as if it were multiple arguments.</p>

<p>Example: <code>struct medium { long a1, a2; }</code></p></li>

<li><p>A structure that’s larger than four machine words is always passed on the
stack.</p>

<p>Example: <code>struct large { long a, b, c, d, e, f, g; }</code></p></li>

<li><p>Floating point arguments are generally passed in special registers, the
“SSE registers,” that we don’t discuss further.</p></li>

<li><p>If the return value takes more than eight bytes, then the <em>caller</em> reserves
space for the return value, and passes the <em>address</em> of that space as the
first argument of the function. The callee will fill in that space when it
returns.</p></li>
</ol>

<p>Writing small programs to demonstrate these rules is a pleasant exercise; for
example:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#007020;font-weight:bold">struct</span> <span style="color:#0e84b5;font-weight:bold">small</span> { <span style="color:#902000">char</span> a1, a2; };
<span style="color:#902000">int</span> <span style="color:#06287e">f</span>(small s) {
    <span style="color:#007020;font-weight:bold">return</span> s.a1 <span style="color:#666">+</span> <span style="color:#40a070">2</span> <span style="color:#666">*</span> s.a2;
}
</code></pre></div>
<p>compiles to:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#06287e">movl</span> <span style="color:#bb60d5">%edi</span>, <span style="color:#bb60d5">%eax</span>           <span style="color:#60a0b0;font-style:italic"># copy argument to %eax
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#60add5">movsbl</span> <span style="color:#bb60d5">%dil</span>, <span style="color:#bb60d5">%edi</span>         <span style="color:#60a0b0;font-style:italic"># %edi := sign-extension of lowest byte of argument (s.a1)
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#60add5">movsbl</span> <span style="color:#bb60d5">%ah</span>, <span style="color:#bb60d5">%eax</span>          <span style="color:#60a0b0;font-style:italic"># %eax := sign-extension of 2nd byte of argument (s.a2)
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#60add5">movsbl</span> <span style="color:#bb60d5">%al</span>, <span style="color:#bb60d5">%eax</span>
<span style="color:#06287e">leal</span> (<span style="color:#bb60d5">%rdi</span>,<span style="color:#bb60d5">%rax</span>,<span style="color:#40a070">2</span>), <span style="color:#bb60d5">%eax</span>  <span style="color:#60a0b0;font-style:italic"># %eax := %edi + 2 * %eax
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#60add5">ret</span></code></pre></div>
<h2 id="stack">Stack</h2>

<p><a href="https://cs61.seas.harvard.edu/site/2018/Datarep3">Recall</a> that the stack is a segment of memory used to store
objects with automatic lifetime. Typical stack addresses on x86-64 look like
<code>0x7ffd'9f10'4f58</code>—that is, close to 2<sup>47</sup>.</p>

<p>The stack is named after a data structure, which was sort of named after
pancakes. Stack data structures support at least three operations: <strong>push</strong>
adds a new element to the “top” of the stack; <strong>pop</strong> removes the top element,
showing whatever was underneath; and <strong>top</strong> accesses the top element. Note
what’s missing: the data structure does not allow access to elements other
than the top. (Which is sort of how stacks of pancakes work.) This restriction
can speed up stack implementations.</p>

<p>Like a stack data structure, the stack memory segment is only accessed from
the top. The currently running function accesses <em>its</em> local variables; the
function’s caller, grand-caller, great-grand-caller, and so forth are dormant
until the currently running function returns.</p>

<p>x86-64 stacks look like this:</p>

<p></p><figure><img src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/stack-2018-01.png" alt="Stack"></figure><p></p>

<p>The x86-64 <code>%rsp</code> register is a special-purpose register that defines the
current “stack pointer.” This holds the address of the current top of the
stack. On x86-64, as on many architectures, stacks grow <em>down</em>: a “push”
operation adds space for more automatic-lifetime objects by moving the stack
pointer left, to a numerically-smaller address, and a “pop” operation recycles
space by moving the stack pointer right, to a numerically-larger address. This
means that, considered numerically, the “top” of the stack has a smaller
address than the “bottom.”</p>

<p>This is built in to the architecture by the operation of instructions like
<code>pushq</code>, <code>popq</code>, <code>call</code>, and <code>ret</code>. A <code>push</code> instruction pushes a value onto
the stack. This both modifies the stack pointer (making it smaller) and
modifies the stack segment (by moving data there). For instance, the
instruction <code>pushq X</code> means:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#06287e">subq</span> <span style="color:#60add5">$8</span>, <span style="color:#bb60d5">%rsp</span>
<span style="color:#06287e">movq</span> <span style="color:#60add5">X</span>, (<span style="color:#bb60d5">%rsp</span>)</code></pre></div>
<p>And <code>popq X</code> undoes the effect of <code>pushq X</code>. It means:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#06287e">movq</span> (<span style="color:#bb60d5">%rsp</span>), <span style="color:#60add5">X</span>
<span style="color:#06287e">addq</span> <span style="color:#60add5">$8</span>, <span style="color:#bb60d5">%rsp</span></code></pre></div>
<p><code>X</code> can be a register or a memory reference.</p>

<p>The portion of the stack reserved for a function is called that function’s
<strong>stack frame</strong>. Stack frames are aligned: x86-64 requires that each stack
frame be a multiple of 16 bytes, and when a <code>callq</code> instruction begins
execution, the <code>%rsp</code> register must be 16-byte aligned. This means that every
function’s entry <code>%rsp</code> address will be 8 bytes off a multiple of 16.</p>

<h2 id="return-address-and-entry-and-exit-sequence">Return address and entry and exit sequence</h2>

<p>The steps required to call a function are sometimes called the <em>entry
sequence</em> and the steps required to return are called the <em>exit sequence</em>.
Both caller and callee have responsibilities in each sequence.</p>

<p>To prepare for a function call, the caller performs the following tasks in its
entry sequence.</p>

<ol>
<li><p>The caller stores the first six arguments in the corresponding registers.</p></li>

<li><p>If the callee takes more than six arguments, or if some of its arguments
are large, the caller must store the surplus arguments on its stack frame.
It stores these in increasing order, so that the 7th argument has a smaller
address than the 8th argument, and so forth. The 7th argument must be
stored at <code>(%rsp)</code> (that is, the top of the stack) when the caller executes
its <code>callq</code> instruction.</p></li>

<li><p>The caller saves any caller-saved registers (see below).</p></li>

<li><p>The caller executes <code>callq FUNCTION</code>. This has an effect like <code>pushq
$NEXT_INSTRUCTION; jmp FUNCTION</code> (or, equivalently, <code>subq $8, %rsp; movq
$NEXT_INSTRUCTION, (%rsp); jmp FUNCTION</code>), where <code>NEXT_INSTRUCTION</code> is the
address of the instruction immediately following <code>callq</code>.</p></li>
</ol>

<p>This leaves a stack like this:</p>

<p></p><figure><img src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/stack-2018-02.png" alt="Initial stack at start of function"></figure><p></p>

<p>To return from a function:</p>

<ol>
<li><p>The callee places its return value in <code>%rax</code>.</p></li>

<li><p>The callee restores the stack pointer to its value at entry (“entry
<code>%rsp</code>”), if necessary.</p></li>

<li><p>The callee executes the <code>retq</code> instruction. This has an effect like <code>popq
%rip</code>, which removes the return address from the stack and jumps to that
address.</p></li>

<li><p>The caller then cleans up any space it prepared for arguments and restores
caller-saved registers if necessary.</p></li>
</ol>

<p>Particularly simple callees don’t need to do much more than return, but most
callees will perform more tasks, such as allocating space for local variables
and calling functions themselves.</p>

<h2 id="calleesaved-registers-and-callersaved-registers">Callee-saved registers and caller-saved registers</h2>

<p>The calling convention gives callers and callees certain guarantees and
responsibilities about the values of registers across function calls. Function
implementations may expect these guarantees to hold, and must work to fulfill
their responsibilities.</p>

<p>The most important responsibility is that certain registers’ values <em>must be
preserved across function calls</em>. A callee may use these registers, but if it
changes them, it must restore them to their original values before returning.
These registers are called <strong>callee-saved registers</strong>. All other registers are
<strong>caller-saved</strong>.</p>

<p>Callers can simply use callee-saved registers across function calls; in this
sense they behave like C++ local variables. Caller-saved registers behave
differently: if a caller wants to preserve the value of a caller-saved
register across a function call, the caller must explicitly save it before the
<code>callq</code> and restore it when the function resumes.</p>

<p>On x86-64 Linux, <code>%rbp</code>, <code>%rbx</code>, <code>%r12</code>, <code>%r13</code>, <code>%r14</code>, and <code>%r15</code> are
callee-saved, as (sort of) are <code>%rsp</code> and <code>%rip</code>. The other registers are
caller-saved.</p>

<h2 id="base-pointer-frame-pointer">Base pointer (frame pointer)</h2>

<p>The <code>%rbp</code> register is called the <em>base pointer</em> (and sometimes the <em>frame
pointer</em>). For simple functions, an optimizing compiler generally treats this
like any other callee-saved general-purpose register. However, for more
complex functions, <code>%rbp</code> is used in a specific pattern that facilitates
debugging. It works like this:</p>

<p></p><figure><img src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/stack-2018-03.png" alt="Stack frame with base pointer"></figure><p></p>

<ol>
<li><p>The first instruction executed on function entry is <code>pushq %rbp</code>. This
saves the caller’s value for <code>%rbp</code> into the callee’s stack. (Since <code>%rbp</code>
is callee-saved, the callee must save it.)</p></li>

<li><p>The second instruction is <code>movq %rsp, %rbp</code>. This saves the current stack
pointer in <code>%rbp</code> (so <code>%rbp</code> = entry <code>%rsp</code> - 8).</p>

<p>This adjusted value of <code>%rbp</code> is the callee’s “frame pointer.” The callee
will not change this value until it returns. The frame pointer provides a
stable reference point for local variables and caller arguments. (Complex
functions may need a stable reference point because they reserve varying
amounts of space for calling different functions.)</p>

<p>Note, also, that the value stored at <code>(%rbp)</code> is the <em>caller’s</em> <code>%rbp</code>,
and the value stored at <code>8(%rbp)</code> is the return address. This information
can be used to trace backwards through callers’ stack frames by functions
such as debuggers.</p></li>

<li><p>The function ends with <code>movq %rbp, %rsp; popq %rbp; retq</code>, or,
equivalently, <code>leave; retq</code>. This sequence restores the caller’s <code>%rbp</code> and
entry <code>%rsp</code> before returning.</p></li>
</ol>

<h2 id="stack-size-and-red-zone">Stack size and red zone</h2>

<p>Functions execute fast because allocating space within a function is simply a
matter of decrementing <code>%rsp</code>. This is much cheaper than a call to <code>malloc</code> or
<code>new</code>! But making this work takes a lot of machinery. We’ll see this in more
detail later; but in brief: The operating system knows that <code>%rsp</code> points to
the stack, so if a function accesses nonexistent memory near <code>%rsp</code>, the OS
assumes it’s for the stack and transparently allocates new memory there.</p>

<p>So how can a program “run out of stack”? The operating system puts a limit on
each function’s stack, and if <code>%rsp</code> gets too low, the program segmentation
faults.</p>

<p>The diagram above also shows a nice feature of the x86-64 architecture, namely
the <strong>red zone</strong>. This is a small area <em>above</em> the stack pointer (that is, at
lower addresses than <code>%rsp</code>) that can be used by the currently-running
function for local variables. The red zone is nice because it can be used
without mucking around with the stack pointer; for small functions <code>push</code> and
<code>pop</code> instructions end up taking time.</p>

<h2 id="branches">Branches</h2>

<p>The processor typically executes instructions in sequence, incrementing <code>%rip</code>
each time. Deviations from sequential instruction execution, such as function
calls, are called <strong>control flow transfers</strong>.</p>

<p>Function calls aren’t the only kind of control flow transfer. A <em>branch</em>
instruction jumps to a new instruction without saving a return address on the
stack.</p>

<p>Branches come in two flavors, unconditional and conditional. The <code>jmp</code> or <code>j</code>
instruction executes an unconditional branch (like a <code>goto</code>). All other branch
instructions are conditional: they only branch if some condition holds. That
condition is represented by <strong>condition flags</strong> that are set as a side effect
of every arithmetic operation.</p>

<p>Arithmetic instructions change part of the <code>%rflags</code> register as a
side effect of their operation. The most often used flags are:</p>

<ul>
<li><strong>ZF</strong> (zero flag): set iff the result was zero.</li>
<li><strong>SF</strong> (sign flag): set iff the most significant bit (the sign bit)
of the result was one (i.e., the result was negative if considered
as a signed integer).</li>
<li><strong>CF</strong> (carry flag): set iff the result overflowed when considered
as unsigned (i.e., the result was greater than 2<sup>W</sup>-1).</li>
<li><strong>OF</strong> (overflow flag): set iff the result overflowed when
considered as signed (i.e., the result was greater than
2<sup>W-1</sup>-1 or less than –2<sup>W-1</sup>).</li>
</ul>

<p>Although some instructions let you load specific flags into registers
(e.g., <code>setz</code>; see CS:APP3e §3.6.2, p203), code more often accesses
them via conditional jump or conditional move
instructions.</p>

<table class="alternate padleft">
<thead>
<tr>
<th>Instruction</th>
<th>Mnemonic</th>
<th>C example</th>
<th>Flags</th>
</tr>
</thead>

<tbody>
<tr>
<td>j (jmp)</td>
<td>Jump</td>
<td><code>break;</code></td>
<td>(Unconditional)</td>
</tr>

<tr>
<td>je (jz)</td>
<td>Jump if equal (zero)</td>
<td><code>if (x == y)</code></td>
<td>ZF</td>
</tr>

<tr>
<td>jne (jnz)</td>
<td>Jump if not equal (nonzero)</td>
<td><code>if (x != y)</code></td>
<td>!ZF</td>
</tr>

<tr>
<td>jg (jnle)</td>
<td>Jump if greater</td>
<td><code>if (x &gt; y)</code>, signed</td>
<td>!ZF &amp;&amp; !(SF ^ OF)</td>
</tr>

<tr>
<td>jge (jnl)</td>
<td>Jump if greater or equal</td>
<td><code>if (x &gt;= y)</code>, signed</td>
<td>!(SF ^ OF)</td>
</tr>

<tr>
<td>jl (jnge)</td>
<td>Jump if less</td>
<td><code>if (x &lt; y)</code>, signed</td>
<td>SF ^ OF</td>
</tr>

<tr>
<td>jle (jng)</td>
<td>Jump if less or equal</td>
<td><code>if (x &lt;= y)</code>, signed</td>
<td>(SF ^ OF) || ZF</td>
</tr>

<tr>
<td>ja (jnbe)</td>
<td>Jump if above</td>
<td><code>if (x &gt; y)</code>, unsigned</td>
<td>!CF &amp;&amp; !ZF</td>
</tr>

<tr>
<td>jae (jnb)</td>
<td>Jump if above or equal</td>
<td><code>if (x &gt;= y)</code>, unsigned</td>
<td>!CF</td>
</tr>

<tr>
<td>jb (jnae)</td>
<td>Jump if below</td>
<td><code>if (x &lt; y)</code>, unsigned</td>
<td>CF</td>
</tr>

<tr>
<td>jbe (jna)</td>
<td>Jump if below or equal</td>
<td><code>if (x &lt;= y)</code>, unsigned</td>
<td>CF || ZF</td>
</tr>

<tr>
<td>js</td>
<td>Jump if sign bit</td>
<td><code>if (x &lt; 0)</code>, signed</td>
<td>SF</td>
</tr>

<tr>
<td>jns</td>
<td>Jump if not sign bit</td>
<td><code>if (x &gt;= 0)</code>, signed</td>
<td>!SF</td>
</tr>

<tr>
<td>jc</td>
<td>Jump if carry bit</td>
<td>N/A</td>
<td>CF</td>
</tr>

<tr>
<td>jnc</td>
<td>Jump if not carry bit</td>
<td>N/A</td>
<td>!CF</td>
</tr>

<tr>
<td>jo</td>
<td>Jump if overflow bit</td>
<td>N/A</td>
<td>OF</td>
</tr>

<tr>
<td>jno</td>
<td>Jump if not overflow bit</td>
<td>N/A</td>
<td>!OF</td>
</tr>
</tbody>
</table>

<p>The <code>test</code> and <code>cmp</code> instructions are frequently seen before a
conditional branch. These operations perform arithmetic but throw away
the result, except for condition codes. <code>test</code> performs binary-and,
<code>cmp</code> performs subtraction.</p>

<p><code>cmp</code> is hard to grasp: remember that <code>subq %rax, %rbx</code> performs
<code>%rbx := %rbx - %rax</code>—the source/destination operand is on the left. So <code>cmpq %rax, %rbx</code>
evaluates <code>%rbx - %rax</code>. The sequence <code>cmpq %rax, %rbx; jg L</code> will jump to
label <code>L</code> if and only if <code>%rbx</code> is greater than <code>%rax</code> (signed).</p>

<p>The weird-looking instruction <code>testq %rax, %rax</code>, or more generally <code>testq
REG, SAMEREG</code>, is used to load the condition flags appropriately for a single
register. For example, the bitwise-and of <code>%rax</code> and <code>%rax</code> is zero if and
only if <code>%rax</code> is zero,  so <code>testq %rax, %rax; je L</code> jumps to <code>L</code> if and only
if <code>%rax</code> is zero.</p>

<h2 id="sidebar-c-data-structures">Sidebar: C++ data structures</h2>

<p>C++ compilers and data structure implementations have been designed to avoid
the so-called <em>abstraction penalty</em>, which is when convenient data structures
compile to more and more-expensive instructions than simple, raw memory
accesses. When this works, it works quite well; for example, this:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#902000">long</span> <span style="color:#06287e">f</span>(std<span style="color:#666">::</span>vector<span style="color:#666">&lt;</span><span style="color:#902000">int</span><span style="color:#666">&gt;&amp;</span> v) {
    <span style="color:#902000">long</span> sum <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    <span style="color:#007020;font-weight:bold">for</span> (<span style="color:#007020;font-weight:bold">auto</span><span style="color:#666">&amp;</span> <span style="color:#002070;font-weight:bold">i</span> : v) {
        sum <span style="color:#666">+=</span> i;
    }
    <span style="color:#007020;font-weight:bold">return</span> sum;
}
</code></pre></div>
<p>compiles to this, a very tight loop similar to the C version:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">        <span style="color:#06287e">movq</span>    (<span style="color:#bb60d5">%rdi</span>), <span style="color:#bb60d5">%rax</span>
        <span style="color:#06287e">movq</span>    <span style="color:#40a070">8</span>(<span style="color:#bb60d5">%rdi</span>), <span style="color:#bb60d5">%rcx</span>
        <span style="color:#06287e">cmpq</span>    <span style="color:#bb60d5">%rcx</span>, <span style="color:#bb60d5">%rax</span>
        <span style="color:#06287e">je</span>      <span style="color:#60add5">.L4</span>
        <span style="color:#06287e">movq</span>    <span style="color:#bb60d5">%rax</span>, <span style="color:#bb60d5">%rdx</span>
        <span style="color:#06287e">addq</span>    <span style="color:#60add5">$4</span>, <span style="color:#bb60d5">%rax</span>
        <span style="color:#06287e">subq</span>    <span style="color:#bb60d5">%rax</span>, <span style="color:#bb60d5">%rcx</span>
        <span style="color:#06287e">andq</span>    <span style="color:#60add5">$-4</span>, <span style="color:#bb60d5">%rcx</span>
        <span style="color:#06287e">addq</span>    <span style="color:#bb60d5">%rax</span>, <span style="color:#bb60d5">%rcx</span>
        <span style="color:#06287e">movl</span>    <span style="color:#60add5">$0</span>, <span style="color:#bb60d5">%eax</span>
<span style="color:#002070;font-weight:bold">.L3:</span>
        <span style="color:#06287e">movslq</span>  (<span style="color:#bb60d5">%rdx</span>), <span style="color:#bb60d5">%rsi</span>
        <span style="color:#06287e">addq</span>    <span style="color:#bb60d5">%rsi</span>, <span style="color:#bb60d5">%rax</span>
        <span style="color:#06287e">addq</span>    <span style="color:#60add5">$4</span>, <span style="color:#bb60d5">%rdx</span>
        <span style="color:#06287e">cmpq</span>    <span style="color:#bb60d5">%rcx</span>, <span style="color:#bb60d5">%rdx</span>
        <span style="color:#06287e">jne</span>     <span style="color:#60add5">.L3</span>
        <span style="color:#4070a0">rep</span> <span style="color:#06287e">ret</span>
<span style="color:#002070;font-weight:bold">.L4:</span>
        <span style="color:#06287e">movl</span>    <span style="color:#60add5">$0</span>, <span style="color:#bb60d5">%eax</span>
        <span style="color:#06287e">ret</span></code></pre></div>
<p>We can also use this output to infer some aspects of <code>std::vector</code>’s
implementation. It looks like:</p>

<ul>
<li>The first element of a <code>std::vector</code> structure is a pointer to the first
element of the vector;</li>
<li>The elements are stored in memory in a simple array;</li>
<li>The second element of a <code>std::vector</code> structure is a pointer to
<em>one-past-the-end</em> of the elements of the vector (i.e., if the vector is
empty, the first and second elements of the structure have the same value).</li>
</ul>

    </div>
</div>

        <script src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/jquery-3.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
        <script src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/popper.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
        <script src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/bootstrap.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
        <script src="Assembly%202%20%20Calling%20convention%20%E2%80%93%20CS%2061_files/katex.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
        <script>(function () {
        jQuery.fn.extend({
            geometry: function (outer) {
                var x;
                if (this[0] == window)
                    x = {left: this.scrollLeft(), top: this.scrollTop()};
                else
                    x = this.offset();
                if (x) {
                    x.width = outer ? this.outerWidth() : this.width();
                    x.height = outer ? this.outerHeight() : this.height();
                    x.right = x.left + x.width;
                    x.bottom = x.top + x.height;
                }
                return x;
            }
        });
        $(".math").each(function () {
            var t = this.innerText,
                opt = {throwOnError: false, displayMode: t.substr(0, 2) === "\\["};
            katex.render(t.replace(/(?:^\\\(|^\\\[|\\\)$|\\\]$)/g, ""), this, opt);
        });
        function sol_toggle(hide, storage) {
            this.childNodes[0].classList.toggle("hidden", !hide);
            this.childNodes[0].classList.toggle("shown", hide);
            this.childNodes[1].classList.toggle("hidden", hide);
            this.childNodes[1].classList.toggle("shown", !hide);
            if (storage) {
                var key = location.href + " " + $(".has-solution").index(this);
                if (hide)
                    sessionStorage.removeItem(key);
                else
                    sessionStorage.setItem(key, true);
            }
        }
        $(".solution").each(function () {
            $(this).wrap('<div class="has-solution"></div>');
            var sol = this.parentElement;
            $(sol).prepend('<blockquote class="solution-collapsed js-solution show"><a href="" class="js-solution show"></a></blockquote>');
            $(this).append('<p><a href="" class="js-solution hide"></a></p>');
            $(sol).find("a.js-solution.show").text(this.getAttribute("data-show-text") || "Show solution");
            $(sol).find("a.js-solution.hide").text(this.getAttribute("data-hide-text") || "Hide solution");
            var key = location.href + " " + $(".has-solution").index(sol);
            if (sessionStorage.getItem(key))
                sol_toggle.call(sol, false, false);
        });
        $(document).on("click", ".js-solution", function (event) {
            if (this.classList.contains("all")) {
                var hide = this.classList.contains("hide");
                $(".has-solution").each(function () {
                    sol_toggle.call(this, hide, false);
                });
                var bq = this.tagName === "BLOCKQUOTE" ? this : this.parentElement;
                $(bq).find(".show").toggleClass("hidden", !hide);
                $(bq).find(".hide").toggleClass("hidden", hide);
            } else {
                var sol = $(this).closest(".has-solution")[0];
                sol_toggle.call(sol, this.classList.contains("hide"), true);
            }
            event.preventDefault();
            event.stopPropagation();
        });
        var container = $(".container")[0];
        function slideview_toggle(hide, storage) {
            if (hide === null)
                hide = container.classList.contains("container-slides");
            container.classList.toggle("container-slides", !hide);
            if (storage) {
                var key = location.href + " slides";
                if (hide)
                    sessionStorage.removeItem(key);
                else
                    sessionStorage.setItem(key, true);
            }
        }
        function slideview_setpos(pos) {
            var slidecount = +this.getAttribute("data-reveal-steps");
            var es = [this], n = this.nextSibling;
            while (n && n.tagName !== "H2") {
                es.push(n);
                n = n.nextSibling;
            }
            $(es).find("[data-reveal]").add($(es).filter("[data-reveal]")).each(function () {
                $(this).toggleClass("hidden", +this.getAttribute("data-reveal") > pos);
            });
            this.setAttribute("data-reveal-pos", pos);
        }
        function slideview_keypress(event) {
            if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey
                || (event.keyCode != 37 && event.keyCode != 39)
                || !container.classList.contains("container-slides"))
                return;
            var isleft = event.keyCode == 37, space = 20, slop = space + 5;
            var w = $(window).geometry(), divs = $("h2"), i;
            for (i = isleft ? divs.length - 1 : 0;
                 i >= 0 && i < divs.length;
                 i += (isleft ? -1 : 1)) {
                var d = divs[i], g = $(d).geometry();
                if (g.top - slop < w.top
                    && g.top + slop > w.top
                    && d.hasAttribute("data-reveal-steps")) {
                    var slidecount = +d.getAttribute("data-reveal-steps");
                    var slidepos = +d.getAttribute("data-reveal-pos") + (isleft ? -1 : 1);
                    if (isleft ? slidepos >= 0 : slidepos < slidecount) {
                        slideview_setpos.call(d, slidepos);
                        break;
                    }
                }
                if (isleft ? g.top + slop < w.top : g.top > w.top + slop) {
                    $(window).scrollTop(g.top - space);
                    if (d.hasAttribute("data-reveal-steps")) {
                        slideview_setpos.call(d, isleft ? +d.getAttribute("data-reveal-steps") - 1 : 0);
                    }
                    break;
                }
            }
            if (i < 0)
                $(window).scrollTop(0);
            event.preventDefault();
        }
        $(document).on("click", ".js-toggle-slideview", function (event) {
            slideview_toggle(null, true);
            event.preventDefault();
            event.stopPropagation();
        });
        $(".need-container-slides").each(function () {
            $(this).prepend('<blockquote class="slideview-toggle"><a href="" class="js-toggle-slideview">Toggle slide view</a></blockquote>').removeClass("need-container-slides");
            var key = location.href + " slides";
            if (sessionStorage.getItem(key))
                slideview_toggle(false, false);
            $("body").on("keyup", slideview_keypress);
        });
        })()</script>
    


<table style="width: 157px; display: none; top: 44px; left: 602px; position: absolute;" class="gstl_50 gssb_c" cellspacing="0" cellpadding="0"><tbody><tr><td class="gssb_f"></td><td class="gssb_e" style="width: 100%;"></td></tr></tbody></table></body></html>